'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); //
//  BlockV AG. Copyright (c) 2018, all rights reserved.
//
//  Licensed under the BlockV SDK License (the "License"); you may not use this file or
//  the BlockV SDK except in compliance with the License accompanying it. Unless
//  required by applicable law or agreed to in writing, the BlockV SDK distributed under
//  the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
//  ANY KIND, either express or implied. See the License for the specific language
//  governing permissions and limitations under the License.
//


var _jwtDecode = require('jwt-decode');

var _jwtDecode2 = _interopRequireDefault(_jwtDecode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UserManager = function () {
  function UserManager(UserApi, store) {
    _classCallCheck(this, UserManager);

    this.UserApi = UserApi;
    this.store = store;
  }

  /**
   * Allows a user to be registered on the BlockV system.
   * @param  {String} firstName    Users First Name
   * @param  {String} lastName     Users Last Name
   * @param  {String} birthday     Users Birthday, Format : YYYY-MM-DD
   * @param  {String} language     The user's preferred language. Two letter language code according to ISO 639-1.
   * @param  {String} password     A password for the user to login with
   * @param  {[Array]} tokens        A list of user tokens to identify the user.
   *                                 At least one token is needed to register a user.
   *                                 [
   *                                  {
   *                                    token : "someone@blockv.org",
   *                                    token_type : "email"
   *                                  }
   *                                 ]
   * @param  {Bool} namePublic   TRUE / FALSE
   * @param  {Bool} avatarPublic TRUE / FALSE
   * @return {Promise<Object>}  Returns a success Object containing users specific information.
   */

  _createClass(UserManager, [{
    key: 'register',
    value: function register(firstName, lastName, birthday, language, password, tokens, namePublic, avatarPublic) {
      return this.UserApi.register(new RegisterRequest(firstName, lastName, birthday, language, password, tokens, namePublic, avatarPublic));
    }

    /**
     * An Alternate version of the register function, It contains an obect instead of inline parameters
     * @param  {Object} registration An Object containing all the information required to register a user.
     * @return {Promise<Object>} returns a success Object containing user specific information
     */

  }, {
    key: 'register',
    value: function register(registration) {
      return this.UserApi.register(registration);
    }

    /**
     * Allows the user to login to the platform
     * @param  {String} token     Email / Phone Number of the user
     * @param  {String} tokenType Description of the token : ie. "phone_number" or "email"
     * @param  {String} password  The password that the user has set
     * @return {Promise<Object>} returns a object containing the information for the user that has logged in.
     */

  }, {
    key: 'login',
    value: function login(token, tokenType, password) {
      return this.UserApi.login(token, tokenType, password);
    }

    /**
     * Login with an Account without registering. A unique login string is generated by the server.
     * @param  {String} guestId A String generated by the server used to login.
     *                            A Guest account can be made into a registered account by patching
     * @return {Promise<Object>}         A Object that contains specific information about the guest user that was logged in.
     */

  }, {
    key: 'loginGuest',
    value: function loginGuest(guestId) {
      return this.UserApi.loginGuest(guestId);
    }

    /**
     * Logs out the currently logged in user.
     * @return {Promise<Object>} Logout success message
     */

  }, {
    key: 'logout',
    value: function logout() {
      return this.UserApi.logout();
    }

    /**
     * Gets information about the currently logged in user.
     * @return {Promise<Object>} Contains the users information such as ID, Avatar, Name etc.
     */

  }, {
    key: 'getCurrentUser',
    value: function getCurrentUser() {
      return this.UserApi.getCurrentUser();
    }

    /**
     * Returns a list of user tokens
     * @return {Promise<Object>} An Object containing a list of Email Address's and Phone Number's for the user.
     */

  }, {
    key: 'getCurrentUserTokens',
    value: function getCurrentUserTokens() {
      return this.UserApi.getUserTokens();
    }

    /**
     * Allows the uploading of a new avatar for the user.
     * @param  {FormData} formData Uploads the FormData containing the new avatar for the user
     * @return {Promise<Object>}   An Object containing a upload success message
     */

  }, {
    key: 'uploadAvatar',
    value: function uploadAvatar(formData) {
      this.UserApi.uploadAvatar(formData);
    }

    /**
     * Allows the user to be edited
     * @param  {Object} payload A payload containg the fields to be changed for the user. eg.{"first_name" : "John"}
     * @return {Promise<Object>} returns a user Object containing the users info with the current changed fields.
     */

  }, {
    key: 'updateUser',
    value: function updateUser(payload) {
      return this.UserApi.updateUser(payload);
    }

    /**
     * Returns the Access Token
     * @return {Promise<Object>} Returns a Object containing the Access Token String.
     */

  }, {
    key: 'getAccessToken',
    value: function getAccessToken() {
      return this.UserApi.getAccessToken();
    }

    /**
     * Automatically Encodes the Asset Provides URI's
     * @param {String} url The URL that needs to be encoded
     */

  }, {
    key: 'encodeAssetProvider',
    value: function encodeAssetProvider(url) {
      return this.UserApi.encodeAssetProvider(url);
    }

    /**
     * Sends a Verification Token to verify the token is valid
     * @param  {String} token      Phone Number / Email Address
     * @param  {String} token_type Description of the Token above ie. "phone_number" / "email"
     * @return {}   An Email / SMS will be sent to the token with a verification code.
     */

  }, {
    key: 'sendTokenVerification',
    value: function sendTokenVerification(token, token_type) {
      return this.UserApi.sendTokenVerification(token, token_type);
    }
  }, {
    key: 'getRefreshToken',
    value: function getRefreshToken() {
      return this.UserApi.getRefreshToken();
    }
  }, {
    key: 'setRefreshToken',
    value: function setRefreshToken(token) {
      return this.UserApi.setRefreshToken(token);
    }

    /**
     * Verify a users Token
     * @param  {Object} verify An Object containing the token, token_type and the verification code.
     *                           {"token" : "someone@blockv.org", "token_type" : "email", "verify_code" :  "00000" }
     * @return {Promise<Object>}        An Object containing the outcome of the verification of the token.
     */

  }, {
    key: 'verifyUserToken',
    value: function verifyUserToken(verify) {
      return this.UserApi.verifyUserToken(verify);
    }

    /**
     * Allows additional tokens to be added to the user
     * @param {Object} payload An Object containing the tokens that need to be added to the users profile.
     * @return {Promise<Object>}  An Object with the updated user profile.
     */

  }, {
    key: 'addUserToken',
    value: function addUserToken(payload) {
      return this.UserApi.addUserToken(payload);
    }

    /**
     * Sets the token to be the primary option
     * @param {[type]} tokenID id of the token that needs to be set as the defualt
     */

  }, {
    key: 'setDefaultToken',
    value: function setDefaultToken(tokenID) {
      return this.UserApi.setDefaultToken(tokenID);
    }

    /**
     * Removes a Token from the user's profile.
     * @param  {String} tokenId ID of the token that needs to be deleted
     * @return {Promise<Object>} A Success / Faile object with the outcome of the deletion.
     */

  }, {
    key: 'deleteUserToken',
    value: function deleteUserToken(tokenId) {
      return this.UserApi.deleteUserToken(tokenId);
    }
  }, {
    key: 'getGuestToken',
    value: function getGuestToken() {
      return this.UserApi.getGuestToken();
    }

    /**
     * Sends a verification token to the token that was supplied... NB! this will remove the current users password.
     * @param {String} token   The Token that needs to be reset (Phone Number / Email Address)
     * @param {String} token_type Description of the Token to be reset
     */

  }, {
    key: 'resetPassword',
    value: function resetPassword(token, token_type) {
      return this.UserApi.resetPassword(token, token_type);
    }

    /**
     * Returns a Public User Profile
     * @param  {String} userID Public User ID
     * @return {Promise<Object>}  Returns a Public User Object
     */

  }, {
    key: 'getPublicUserProfile',
    value: function getPublicUserProfile(userID) {
      return this.UserApi.getPublicUserProfile(userID);
    }
  }, {
    key: 'addRedeemable',
    value: function addRedeemable(payload) {
      return this.UserApi.addRedeemable(payload);
    }

    /**
     * Checked to see if the refresh token is valid
     * @return {Boolean} returns True / False if the refresh token is valid
     */

  }, {
    key: 'isLoggedIn',
    get: function get() {
      //define our vars
      var decodedToken = void 0,
          nowDate = void 0,
          expirationTime = void 0,
          refreshToken = void 0;
      refreshToken = this.store.refreshToken;

      // if no refreshToken
      if (!refreshToken) return false;

      try {
        //decode token
        decodedToken = (0, _jwtDecode2.default)(this.store.refreshToken);
        expirationTime = decodedToken.exp * 1000;
        nowDate = Date.now();

        //quick calc to determine if the token has expired
        if (nowDate - 30000 > expirationTime) return false;else return true;
      } catch (e) {
        //decoding fails
        return false;
      }
    }
  }]);

  return UserManager;
}();

exports.default = UserManager;